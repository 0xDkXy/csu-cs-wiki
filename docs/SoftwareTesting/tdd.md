# TDD 测试驱动开发

## 基本概念

测试驱动开发（Test-driven development，TDD）是一种软件开发的应用方法。由于本页面归档在“软件测试”课程 Wiki 中，侧重讲解软件测试角度推动开发的思维以及实践。

从名称中很容易理解 TDD 的含义，以**测试**驱动**开发**，详细点讲，也就是在开发过程中先写测试程序，然后编码实现其功能。在课程 PPT 中这样描述：

> 要求在编写某个功能代码之前先编写测试用例，然后只编写能令测试用例通过的功能代码。

这里的**只编写**，强调 TDD 强调测试的目的性，更严格地讲，未被证明对通过测例有帮助的代码不应该出现在 TDD 开发流程中，这与允许添加这些“冗余”代码的软件开发流程正好相反。

## 背景

<!-- TODO -->

待补充

## TDD 开发流程

### TDD Development Cycle

实际上，TDD 开发是一个短程的开发循环，在课程 PPT 中，我们介绍 TDD 流程如下图：

![TDD](./images/tdd.png)

[Wikipedia](https://en.wikipedia.org/wiki/Test-driven_development)则将 TDD 开发流程拆分为：添加测例、预测试测例、编写代码、执行测试、代码重构，并不断重复这一 Cycle，有兴趣的同学可以自行了解。

### TDD 编程状态

编程状态这个名字是笔者自己起的，课程中描述为“TDD 编程三部曲”，由于实际上说的是测试-代码的二元关系，所以笔者就称之为编程状态了。

- 红灯状态：测试未通过（功能待确认）
- 绿灯状态：测试已通过（功能已确认）
- 重构状态：结构层面的代码优化

一些额外的讨论

#### 关于需求

（由于笔者没有上过软件工程，提到的需求分析可能不大精准）

课程老师强调，应用“系统必须/可以/不能”这样从系统角度撰写需求说明。

#### 关于重构

笔者当时询问课程教师这样一个问题

> 重构状态后不该进行回归测试吗？否则该如何保证重构前后代码的等价性。

老师给出的答复如下。

> 是内容重要，还是形式重要呢？
> 显然是内容。为什么？因为如果内容不正确，而去纠结于形式，形式也会因后续内容变换而改变。
> 故而，先要保证内容正确，然后才去保证形式正确。
> 代码重构是保证形式正确，而回归测试是保证内容正确，先后秩序理应如上所述，不可颠倒。

我理解意思，不过我想他应该错误理解我的问题了，他回复中所指的“回归测试”应该指向的是红灯到绿灯这一过程中的测试，但我的意思是重构后是否应该额外加一个回归测试。的确在 TDD 开发过程中显然是**内容重要性大于形式重要性**，对于“形式的含义”，可以参见另一个讲测试、审查、形式化验证三者关系的页面。

<!-- TODO -->

不过我后来看 Wikipedia 上 TDD 的介绍，在代码重构（Refactor code）后也没有加入测试。不过里面有这样一句话。

> By continually re-running the test cases throughout each refactoring phase, the developer can be confident that process is not altering any existing functionality.

实际上重构过程中代码冗余的判定，仍然是不断通过通过/通不过测例实现的，测例影响着代码重构（而不是我想象中，脱离测例，程序员自己 YY 重构），这样 TDD 的重构过程就可以基本确定不会影响现有功能（或者引入新的问题）。

而考虑重构前后的等价性的确又回到了“证明”上面，这实际上与 TDD 开发理念不相符，所以就像老师回答一样，“哪个重要，内容重要”。而且 TDD 是个 Cycle，大不了转移到下一轮嘛。

## 应用领域

<!-- TODO -->

待补充

## 课程小实验

### 实验内容

依据 TDD 编程流程，编制函数，实现两数相加求和。

### 实验过程

<!-- TODO 指向代码仓库 -->

[详细参见代码仓库](https://github.com/CSU-CS-WIKI/software-testing)。

这里给出一个不完整的测例构造表格，以及部分 TDD 驱动开发过程中的代码。

| 测例编号 | 输入                        | 预计输出    | 实际输出 | 备注                                 |
| :------- | :-------------------------- | :---------- | :------- | :----------------------------------- |
| 1        | a=2147483646 b=1            | 2147483647  |          | 4Bytes int 类型边界测试值。          |
| 2        | a=2147483647 b=1            | 2147483647  |          | 输出值不再能用 4Bytes 表示，转化测试 |
| 3        | a=2147483647 b=2147483647   | 4294967294  |          | 双边界值测试                         |
| 4        | a=-2147483647 b=-1          | -2147483648 |          | 负值 4Bytes int 类型边界测试界       |
| 5        | a=-2147483648 b=-1          | -2147483649 |          | 负值转化测试                         |
| 6        | a=-2147483648 b=-2147483648 | -4294967296 |          | 负值双边界值测试                     |

??? 部分TDD驱动开发实验代码

    ```C++
    /*
    ** 函数名：getAdd
    ** 函数功能：根据两输入值获取商值
    ** 参数名称与类型：
    **  int a
    **  int b
    ** 返回值类型：
    **  long long
    */
    ll getAdd(int a, int b)
    {
        return ll(a) + ll(b);
    }

    /*
    ** 函数名：isNum
    ** 函数功能：用来检测是否为合法输入数
    ** 参数名称与类型：
    **  string s
    ** 返回值：
    **  bool
    */
    bool isNum(string s)
    {
        bool flag = false;
        if (s == "")
            return false;
        rep(i, 0, s.size())
        {
            if (i == 0 && s[i] == '-')
                continue;
            if (s[i] < '0' || s[i] > '9')
                return false;
        }
        return true;
    }
    ```
