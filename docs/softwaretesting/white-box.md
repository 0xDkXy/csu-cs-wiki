# 白盒测试方法

## 基本概念

**白盒测试**（white-box testing）又称**透明盒测试**（glass box testing）、**结构化测试**（structural testing）等，软件测试的主要方法之一。白盒测试是基于代码的测试，测试应用程序的内部结构或运作，而不是测试应用程序的功能（即黑盒测试）。在白盒测试时，以编程语言的角度来设计测试案例。测试者输入数据验证数据流在程序中的流动路径，并确定适当的输出，类似测试电路中的节点。测试者了解待测试程序的内部结构、算法等信息，这是从程序设计者的角度对程序进行的测试。

白盒测试可以应用于单元测试（unit testing）、集成测试（integration testing）和系统的软件测试流程，可测试在集成过程中每一单元之间的路径，或者主系统跟子系统中的测试。尽管这种测试的方法可以发现许多的错误或问题，它可能无法检测未使用部分的规范。

本问后面主要讲白盒测试逻辑覆盖的不同类型（从弱到强），着重对 MC/DC（修正条件/判定覆盖）进行介绍，并补充程序插桩知识以及常见的白盒测试工具。

## 测试技术

### 逻辑覆盖法

白盒测试中的逻辑覆盖主要有以下六种

- 语句覆盖
- 判定覆盖
- 条件覆盖
- 判定－条件覆盖
- 条件组合覆盖
- 路径覆盖

下面逐一解释

#### 语句覆盖

- 基本思想：设计若干测试用例，运行被测程序，使程序中**每个可执行语句至少执行一次**（不考虑分支情况）。
- 优点：可直观得到测例。
- 缺点：由于这种测试方法仅仅针对程序逻辑中显式存在的语句，但**对于隐藏的条件**是无法测试的。如在多分支的逻辑运算中无法全面的考虑。语句覆盖是**最弱的逻辑覆盖**。

#### 判定覆盖

- 基本思想：设计若干测试用例，运行被测程序，使程序中**每个判断的取真分支和取假分支至少经历一次**，**即判断真假值均曾被满足**（不考虑分支内部情况）。
- 优点：可直观得到测例，相对简单，无须细分每个判定。
- 缺点：往往大部分的判定语句是由多个逻辑条件组合而成，若仅仅判断其整个最终结果，而**忽略每个条件的取值情况**，必然会遗漏部分测试路径。判定覆盖仍是**弱的逻辑覆盖**。

#### 条件覆盖

- 基本思想：设计若干测试用例，执行被测程序以后要**使每个判断中每个条件的可能取值至少满足一次**。
- 优点：增加了对条件判定情况的测试，增加了测试路径。
- 缺点：条件覆盖不一定包含判定覆盖，条件覆盖只能保证每个条件（这里没有条件组合）至少有一次为真，而不考虑所有的判定结果。

#### 判定-条件覆盖

- 基本思想：设计足够的测试用例，执行被测程序以后要**使得判断条件中的所有条件可能至少执行一次取值**，**同时**，**所有判断的可能结果至少执行一次**。
- 优点：能同时满足判定、条件两种覆盖标准。
- 缺点：判定/条件覆盖准则的缺点是**未考虑条件的组合**情况。

#### 条件组合覆盖

- 基本思想：设计足够的测试用例，执行被测程序以后要**使得所有可能的条件取值组合至少执行一次**。
- 优点：条件组合覆盖准则满足判定覆盖、条件覆盖和判定/条件覆盖准则。
- 缺点：线性（个人认为是指数）地增加了测试用例的数量。
- 备注：这里解释下，如果各条件变量独立，没有蕴含一类的关系的话，那么$n$条件变量需要设计至少$2^{n}$组样例才能达到条件组合覆盖，这个量是很大的。

#### 路径覆盖

- 基本思想：设计所有的测试用例，来覆盖程序中的所有可能的执行路径 。
- 这种测试方法可以对程序进行彻底的测试，比前面五种的覆盖面都广。
- 需要设计大量、复杂的测试用例，使得工作量呈指数级增长，不见得把所有的条件组合都覆盖。

#### MC/DC 覆盖

**修改条件/判断覆盖**（Modified condition/decision coverage）简称**MC/DC**，是用在飞航安全软件文件 DO-178B 的白箱测试方式，可以判断 A 等级的软件是否有经过适当的软件测试。

依照修改条件/判断覆盖的准则，测试过程中以下条件至少需成立一次

- 每一个判断的所有可能结果都出现过
- 每一个判断中所有条件的所有可能结果都出现过
- 每一个进入点及结束点都执行过
- 判断中每一个条件都可以独立的影响判断的结果

DO-178B 中指定会影响飞机起飞及降落安全性的软件（A 等级软件），需满足修改条件/判断覆盖的代码覆盖测试。

上述内容摘自 Wikipedia。

优点：在枚举全部条件变量组合复杂度与判定-条件覆盖能力不足做了折中，尽可能用**较小测试用例集**达成**高效而全面的测试结果**。

### 程序插桩

<!-- TODO -->

待补充

## 常见的白盒测试工具

<!-- TODO -->

待补充

XUnit，各语言的单元测试框架，多数都贴近白盒测试，比如：JUnit，Google Test，go test 等等。下面给出连接，大家可以自行了解学习。

- [GoogleTest](https://github.com/google/googletest):

  Google Test，谷歌的 C++测试框架，已经在 Github 上开源。包含了 Google Mock，一个应用了 C++ mock classes 的 Google Test 拓展。

- [Go Convey](https://github.com/Edwardzcn/goconvey)

  一个 Golang 的开源测试框架，提供了一些常用的断言形式，配合`go test`使用。比较好的一点是，提供了一个用户友好 Web UI 界面，能比较直观的了解断言通过数、错误点等测试情况。

## 课程小实验

### 实验内容

- 编写判断是否为闰年的程序
- 画出程序的流程图
- 将流程图转换为控制流图
- 基于控制流图，设计该程序的不同标准测试用例集合
  - 语句覆盖
  - 判定覆盖
  - 条件覆盖
  - 路径覆盖
  - MC/DC 覆盖

### 实验过程

<!-- TODO 指向代码仓库 -->

[详细参见代码仓库](https://github.com/CSU-CS-WIKI/software-testing)。

这里只给出核心判断逻辑，以及对应部分覆盖原则的测例构造表格，如 MC/DC 的设计，可以查阅博客进一步学习。

??? 白盒测试核心逻辑代码

    ```C++
    /*
    ** 函数名：checkLeapYear
    ** 函数功能：根据输入年份判断其是否为闰年
    ** 参数名称与类型：
    **  int year
    ** 返回值类型：
    **  bool
    */
    bool checkLeapYear(int year)
    {
        // 判断闰年的核心逻辑
        if (year % 400 == 0 || year % 4 == 0 && year % 100 != 0)
        {
            return true;
        }
        return false;
    }
    ```

在核心逻辑代码中，判断语句仅有一个。为方便后续描述，下列定义：

- 符号$A$表示布尔表达式 `year % 400 == 0`
- 符号$B$表示布尔表达式 `year % 4 == 0`
- 符号$C$表示布尔表达式 `year % 100 != 0`

则判断语句形式化为$A \vee B \wedge C$。实际上$A,B,C$并不是独立的，至少存在下面的蕴含关系：

$$A \Rightarrow B$$

$$A \Rightarrow \overline{C}$$

$$\overline{C} \Rightarrow  B$$

$$\overline{C} \wedge B \Rightarrow A$$

这在构造时要注意。不是完整的笛卡尔乘积，一个子集（关系）的真值表是成立的。

> 注意！由于本题较为特殊，条件间存在蕴含关系，我个人的写法是这样的。更一般的条件独立的情况，以及 MC/DC 测例构造说明，请参见其他文章。[MC/DC 覆盖准则测例构造说明](https://blog.csdn.net/u013935164/article/details/78202260)

- 语句覆盖

  - 概念：**每个可执行语句**至少执行一次
  - 构造：由于只有单一语句，一组测例输入满足语句覆盖。

    | A   | B   | C   | 结果 | 对应测例 |
    | :-- | :-- | :-- | :--- | :------- |
    | 1   | 1   | 0   | 1    | 1600     |

- 判定覆盖

  - 概念：**每个判断**的真假值都至少执行一次
  - 构造：由于只有单一语句，那么构造两组测例使结果相反即可。

    | A   | B   | C   | 结果 | 对应测例 |
    | :-- | :-- | :-- | :--- | :------- |
    | 1   | 1   | 0   | 1    | 1600     |
    | 0   | 1   | 0   | 0    | 200      |
